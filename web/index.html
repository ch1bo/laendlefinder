<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeandleFinder - Real Estate Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        #map {
            height: 100vh;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transition: right 0.3s ease;
        }
        #map.sidebar-open {
            right: 400px;
        }
        #sidebar {
            width: 400px;
            min-width: 350px;
            max-width: 500px;
            background-color: #f8f9fa;
            border-left: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            right: 0;
            height: 100vh;
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        #sidebar.collapsed {
            transform: translateX(100%);
        }
        
        /* Sidebar header with close button */
        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
        }
        .close-button {
            background: white;
            border: 2px solid rgba(0,0,0,0.2);
            border-radius: 4px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            font-size: 16px;
            font-weight: bold;
            color: #333;
            transition: all 0.2s ease;
        }
        .close-button:hover {
            background: #f4f4f4;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            #map {
                height: 100vh !important;
                width: 100% !important;
                right: 0 !important;
                position: absolute;
            }
            #map.sidebar-open {
                right: 0 !important;
            }
            #sidebar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                width: 100%;
                max-width: none;
                min-width: none;
                height: 100vh;
                border-left: none;
                border-top: none;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                z-index: 1000;
                background-color: rgba(248, 249, 250, 0.95);
                backdrop-filter: blur(10px);
            }
            #sidebar:not(.collapsed) {
                transform: translateY(0);
            }
            #sidebar.collapsed {
                transform: translateY(100%);
            }
            .list-toggle {
                position: fixed;
                top: 10px;
                right: 50px;
                left: auto;
                bottom: auto;
                transform: none;
                width: 30px;
                height: 30px;
                border-radius: 4px;
                font-size: 16px;
                z-index: 1002;
                opacity: 1;
                visibility: visible;
            }
            .list-toggle.collapsed {
                top: 10px;
                right: 50px;
                left: auto;
                bottom: auto;
                opacity: 1;
                visibility: visible;
            }
            .filter-toggle {
                position: fixed;
                top: 10px;
                right: 10px;
                left: auto;
                bottom: auto;
                transform: none;
                width: 30px;
                height: 30px;
                border-radius: 4px;
                font-size: 16px;
                z-index: 1002;
                opacity: 1;
                visibility: visible;
            }
            .filter-toggle.collapsed {
                top: 10px;
                right: 10px;
                left: auto;
                bottom: auto;
                opacity: 1;
                visibility: visible;
            }
        }
        
        @media (max-width: 480px) {
            /* No additional changes needed - sidebar uses full overlay */
        }
        .reset-button:hover {
            background: linear-gradient(135deg, #5a6268 0%, #495057 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #property-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        .property-item {
            background-color: white;
            margin-bottom: 10px;
            padding: 12px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-left: 4px solid #ddd;
        }
        .property-item.available {
            border-left-color: #28a745;
        }
        .property-item.sold {
            border-left-color: #dc3545;
        }
        .property-item.unavailable {
            border-left-color: #6c757d;
            background-color: #f8f9fa;
            opacity: 0.85;
        }
        .property-item.unavailable .property-title {
            color: #6c757d;
        }
        .property-item.unavailable .property-price {
            color: #6c757d;
        }
        .property-item.unavailable .property-location {
            color: #868e96;
        }
        .property-item:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            cursor: pointer;
        }
        .property-item.highlighted {
            background-color: #fff3cd;
            border-color: #ffc107;
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
        }
        .property-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            gap: 10px;
        }
        .property-title {
            font-weight: bold;
            color: #333;
            flex: 1;
            margin: 0;
        }
        .property-price {
            color: #2c8a2c;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        .property-location {
            color: #666;
            margin-bottom: 5px;
        }
        .property-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }
        .info-container {
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            max-width: 300px;
        }
        .info-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .info-price {
            color: #2c8a2c;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .info-date {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        .info-address {
            margin-bottom: 5px;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .panel-toggle {
            position: absolute;
            top: 10px;
            z-index: 1001;
            background: white;
            border: 2px solid rgba(0,0,0,0.2);
            border-radius: 4px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 5px rgba(0,0,0,0.65);
            font-size: 16px;
            font-weight: bold;
            color: #333;
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }
        .panel-toggle.collapsed {
            opacity: 1;
            visibility: visible;
        }
        .panel-toggle:hover {
            background: #f4f4f4;
        }
        
        .list-toggle.collapsed {
            right: 50px;
            top: 10px;
        }
        
        .filter-toggle.collapsed {
            right: 10px;
            top: 10px;
        }
        
        .panel-header {
            display: flex;
            background: #e9ecef;
            border-radius: 8px;
            padding: 4px;
            gap: 4px;
            flex: 1;
            margin-right: 8px;
        }
        .panel-tab {
            flex: 1;
            background: transparent;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.2s ease;
        }
        .panel-tab.active {
            background: white;
            color: #2c3e50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .panel-tab:hover:not(.active) {
            background: rgba(255,255,255,0.7);
            color: #495057;
        }
        
        .panel {
            display: none;
            flex: 1;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .panel.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }
        
        .filter-content {
            padding: 16px;
            margin: 8px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border: 1px solid rgba(0,0,0,0.05);
        }
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .filter-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 1em;
            letter-spacing: -0.02em;
            margin: 0;
        }
        .reset-button {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .filter-group {
            margin-bottom: 14px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0,0,0,0.06);
        }
        .filter-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .filter-group label {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            position: relative;
        }
        .filter-group label:hover {
            background-color: rgba(0,123,255,0.05);
            transform: translateX(1px);
        }
        .filter-group label:last-child {
            margin-bottom: 0;
        }
        
        /* Custom checkbox styling */
        .filter-group input[type="checkbox"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #dee2e6;
            border-radius: 3px;
            margin-right: 10px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        .filter-group input[type="checkbox"]:checked {
            background-color: #007bff;
            border-color: #007bff;
        }
        .filter-group input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: -2px;
            left: 1px;
            color: white;
            font-size: 11px;
            font-weight: bold;
        }
        .filter-group input[type="checkbox"]:hover {
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.1);
        }
        
        /* Date histogram and slider styling */
        .date-histogram-container {
            position: relative;
            margin-bottom: 10px;
        }
        .date-histogram {
            height: 60px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            position: relative;
            margin-bottom: 10px;
            overflow: hidden;
        }
        .histogram-bar {
            position: absolute;
            bottom: 0;
            background: linear-gradient(to top, #007bff 0%, #66b3ff 100%);
            border-radius: 1px 1px 0 0;
            transition: opacity 0.2s ease;
        }
        .histogram-bar.dimmed {
            opacity: 0.3;
        }
        .histogram-bar.selected {
            opacity: 1;
        }
        .histogram-bar.empty-month {
            opacity: 0.2;
        }
        .date-slider-container {
            position: relative;
            height: 25px;
            margin: 10px 0;
            background: #dee2e6;
            border-radius: 2px;
        }
        
        .slider-range-fill {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, #28a745 0%, #007bff 100%);
            border-radius: 2px;
            top: 50%;
            transform: translateY(-50%);
            transition: all 0.1s ease;
            z-index: 0;
        }
        
        /* Base slider styling */
        .date-slider {
            position: absolute;
            width: 100%;
            height: 25px;
            background: transparent;
            appearance: none;
            cursor: pointer;
            z-index: 1;
        }
        
        /* Ensure both sliders are accessible */
        #date-slider-min {
            z-index: 1;
        }
        
        #date-slider-min::-webkit-slider-thumb {
            pointer-events: all;
        }
        
        #date-slider-min::-moz-range-thumb {
            pointer-events: all;
        }
        
        #date-slider-max {
            z-index: 2;
            /* Make the max slider's track non-interactive except for the thumb */
            pointer-events: none;
        }
        
        #date-slider-max::-webkit-slider-thumb {
            pointer-events: all;
        }
        
        #date-slider-max::-moz-range-thumb {
            pointer-events: all;
        }
        
        /* Webkit (Chrome/Safari) styling */
        .date-slider::-webkit-slider-track {
            height: 4px;
            background: transparent;
            border-radius: 2px;
            cursor: pointer;
        }
        
        .date-slider::-webkit-slider-thumb {
            appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 3px solid white;
            margin-top: -8px; /* Center on track */
            transition: all 0.2s ease;
        }
        
        .date-slider::-webkit-slider-thumb:hover {
            background: #0056b3;
            transform: scale(1.15);
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
        }
        
        .date-slider::-webkit-slider-thumb:active {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        
        /* Firefox styling */
        .date-slider::-moz-range-track {
            height: 4px;
            background: transparent;
            border-radius: 2px;
            border: none;
        }
        
        .date-slider::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        .date-slider::-moz-range-thumb:hover {
            background: #0056b3;
            transform: scale(1.15);
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
        }
        
        .date-slider::-moz-range-thumb:active {
            transform: scale(1.05);
        }
        
        /* Differentiate the handles visually */
        #date-slider-min::-webkit-slider-thumb {
            background: #28a745; /* Green for min */
        }
        
        #date-slider-min::-webkit-slider-thumb:hover {
            background: #1e7e34;
        }
        
        #date-slider-min::-moz-range-thumb {
            background: #28a745;
        }
        
        #date-slider-min::-moz-range-thumb:hover {
            background: #1e7e34;
        }
        
        /* Blue stays for max handle */
        #date-slider-max::-webkit-slider-thumb {
            background: #007bff;
        }
        
        #date-slider-max::-webkit-slider-thumb:hover {
            background: #0056b3;
        }
        .date-range-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85em;
            color: #495057;
            margin-top: 8px;
        }
        .date-label {
            background: #f8f9fa;
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-weight: 500;
            min-width: 60px;
            text-align: center;
        }
        .clear-dates-btn {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s ease;
            line-height: 1;
            font-weight: 500;
            min-width: 50px;
            text-align: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .clear-dates-btn:hover {
            background: linear-gradient(135deg, #c82333 0%, #bd2130 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        .clear-dates-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        /* Label text styling */
        .filter-group label span:first-of-type {
            flex: 1;
            font-weight: 500;
            color: #495057;
            font-size: 0.9em;
        }
        
        .filter-count {
            background-color: #e9ecef;
            color: #6c757d;
            font-weight: 500;
            font-size: 0.75em;
            padding: 1px 6px;
            border-radius: 10px;
            margin-left: auto;
            min-width: 28px;
            text-align: center;
        }
        .count-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(248, 249, 250, 0.8);
            border-bottom: 1px solid #e9ecef;
        }
        .property-count {
            font-size: 0.8em;
            color: #6c757d;
            font-weight: 500;
        }
        .count-info .reset-button {
            padding: 4px 8px;
            font-size: 0.75em;
            margin-left: 10px;
        }
        .lean-popup {
            background-color: white;
            padding: 12px 14px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            border: 2px solid #007bff;
            font-size: 0.9em;
            line-height: 1.4;
            max-width: 220px;
            cursor: pointer;
            user-select: none;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
        }
        
        @media (max-width: 768px) {
            .lean-popup {
                padding: 14px 16px;
                border-radius: 12px;
                font-size: 1em;
                max-width: 240px;
            }
        }
        .lean-popup .popup-price {
            font-weight: bold;
            color: #2c8a2c;
            margin-bottom: 2px;
        }
        .lean-popup .popup-location {
            color: #333;
            margin-bottom: 2px;
        }
        .lean-popup .popup-type {
            color: #666;
            font-size: 0.8em;
        }
        .popup-tap-hint {
            color: #007bff;
            font-size: 0.75em;
            font-style: italic;
            margin-top: 4px;
            text-align: center;
        }
        .info-listing-type {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }
        .listing-type-available {
            background-color: #e8f5e8;
            color: #2c5f2c;
        }
        .listing-type-sold {
            background-color: #f5e8e8;
            color: #5f2c2c;
        }
        .listing-type-unavailable {
            background-color: #e9ecef;
            color: #6c757d;
        }
        .details-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
            flex-shrink: 0;
            line-height: 1.2;
        }
        .details-button:hover {
            background-color: #0056b3;
            color: white;
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }
    </style>
</head>
<body>
    <div class="list-toggle panel-toggle collapsed" onclick="toggleListPanel()">≡</div>
    <div class="filter-toggle panel-toggle collapsed" onclick="toggleFilterPanel()">⚙</div>
    <div id="map"></div>
    <div id="sidebar" class="collapsed">
        <div class="sidebar-header">
            <div class="panel-header">
                <button class="panel-tab active" id="list-tab" onclick="showPanel('list')">Properties</button>
                <button class="panel-tab" id="filter-tab" onclick="showPanel('filter')">Filters</button>
            </div>
            <button class="close-button" onclick="closeSidebar()">✕</button>
        </div>
        <div id="count-info" class="count-info">
            <span id="property-count" class="property-count">Loading...</span>
            <button class="reset-button" onclick="resetView()">Reset</button>
        </div>
        <div id="property-panel" class="panel active">
            <div id="property-list">
                <div id="loading" class="loading">Loading property data...</div>
            </div>
        </div>
        <div id="filter-panel" class="panel">
            <div class="filter-content">
                <div class="filter-header">
                    <div class="filter-title">Filters</div>
                </div>
                <div class="filter-group">
                    <label>
                        <input type="checkbox" id="filter-available" checked> 
                        <span id="available-label">Available Properties</span>
                        <span id="available-count" class="filter-count"></span>
                    </label>
                    <label>
                        <input type="checkbox" id="filter-sold" checked> 
                        <span id="sold-label">Sold Properties</span>
                        <span id="sold-count" class="filter-count"></span>
                    </label>
                    <label>
                        <input type="checkbox" id="filter-unavailable" checked> 
                        <span id="unavailable-label">Unavailable Properties</span>
                        <span id="unavailable-count" class="filter-count"></span>
                    </label>
                </div>
                <div class="filter-group">
                    <div class="filter-title" style="font-size: 0.9em; margin-bottom: 8px;">Property Types</div>
                    <label>
                        <input type="checkbox" id="filter-apartment" checked> 
                        <span>Wohnung</span>
                        <span id="apartment-count" class="filter-count"></span>
                    </label>
                    <label>
                        <input type="checkbox" id="filter-house" checked> 
                        <span>Haus</span>
                        <span id="house-count" class="filter-count"></span>
                    </label>
                    <label>
                        <input type="checkbox" id="filter-land" checked> 
                        <span>Grundstück</span>
                        <span id="land-count" class="filter-count"></span>
                    </label>
                    <label>
                        <input type="checkbox" id="filter-unknown" checked> 
                        <span>Unbekannt</span>
                        <span id="unknown-count" class="filter-count"></span>
                    </label>
                </div>
                <div class="filter-group">
                    <div class="filter-title" style="font-size: 0.9em; margin-bottom: 8px;">Date Range</div>
                    <div class="date-histogram-container">
                        <div id="date-histogram" class="date-histogram"></div>
                        <div id="date-slider-container" class="date-slider-container">
                            <div id="slider-range-fill" class="slider-range-fill"></div>
                            <input type="range" id="date-slider-min" class="date-slider" min="0" max="100" value="0">
                            <input type="range" id="date-slider-max" class="date-slider" min="0" max="100" value="100">
                        </div>
                        <div class="date-range-labels">
                            <span id="date-range-start" class="date-label">All</span>
                            <button id="clear-dates" class="clear-dates-btn" style="display: none;">Clear</button>
                            <span id="date-range-end" class="date-label">All</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script>
        // Local storage functions for map position
        function saveMapPosition(lat, lng, zoom) {
            const mapPosition = {
                lat: lat,
                lng: lng,
                zoom: zoom,
                timestamp: Date.now()
            };
            localStorage.setItem('laendlefinderMapPosition', JSON.stringify(mapPosition));
        }

        // Local storage functions for filter settings
        function saveFilterSettings() {
            const filterSettings = {
                available: document.getElementById('filter-available').checked,
                sold: document.getElementById('filter-sold').checked,
                unavailable: document.getElementById('filter-unavailable').checked,
                apartment: document.getElementById('filter-apartment').checked,
                house: document.getElementById('filter-house').checked,
                land: document.getElementById('filter-land').checked,
                unknown: document.getElementById('filter-unknown').checked,
                dateMinIndex: minDateIndex,
                dateMaxIndex: maxDateIndex,
                showOnlyVisible: showOnlyVisible,
                timestamp: Date.now()
            };
            localStorage.setItem('laendlefinderFilters', JSON.stringify(filterSettings));
        }

        function getStoredFilterSettings() {
            try {
                const stored = localStorage.getItem('laendlefinderFilters');
                if (stored) {
                    const settings = JSON.parse(stored);
                    // Only use stored settings if they're less than 30 days old
                    const thirtyDaysInMs = 30 * 24 * 60 * 60 * 1000;
                    if (Date.now() - settings.timestamp < thirtyDaysInMs) {
                        return settings;
                    }
                }
            } catch (error) {
                console.warn('Error reading stored filter settings:', error);
            }
            return null;
        }
        
        function getStoredMapPosition() {
            try {
                const stored = localStorage.getItem('laendlefinderMapPosition');
                if (stored) {
                    const position = JSON.parse(stored);
                    // Only use stored position if it's less than 7 days old
                    const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;
                    if (Date.now() - position.timestamp < sevenDaysInMs) {
                        return position;
                    }
                }
            } catch (error) {
                console.warn('Error reading stored map position:', error);
            }
            return null;
        }

        // Local storage functions for panel state
        function savePanelState() {
            const panelState = {
                sidebarCollapsed: sidebarCollapsed,
                timestamp: Date.now()
            };
            localStorage.setItem('laendlefinderPanelState', JSON.stringify(panelState));
        }

        function getStoredPanelState() {
            try {
                const stored = localStorage.getItem('laendlefinderPanelState');
                if (stored) {
                    const state = JSON.parse(stored);
                    // Only use stored state if it's less than 30 days old
                    const thirtyDaysInMs = 30 * 24 * 60 * 60 * 1000;
                    if (Date.now() - state.timestamp < thirtyDaysInMs) {
                        return state;
                    }
                }
            } catch (error) {
                console.warn('Error reading stored panel state:', error);
            }
            return null;
        }

        function restorePanelState() {
            if (!sidebarCollapsed) {
                // If sidebar should be open, apply the open state immediately
                openSidebar();
            }
            // If sidebarCollapsed is true, the default CSS handles the collapsed state
        }
        
        // Initialize the map with stored position or default to Vorarlberg, Austria
        const storedPosition = getStoredMapPosition();
        const initialLat = storedPosition ? storedPosition.lat : 47.2499;
        const initialLng = storedPosition ? storedPosition.lng : 9.9809;
        const initialZoom = storedPosition ? storedPosition.zoom : 10;
        
        const map = L.map('map').setView([initialLat, initialLng], initialZoom);

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Global variables for filtering
        let allProperties = [];
        let markers = [];
        let propertyElements = [];
        let currentHighlightedMarker = null;
        let currentHighlightedProperty = null;
        let filteredProperties = [];
        let displayedProperties = []; // Properties currently shown in the list
        let showOnlyVisible = false;
        let dateHistogramData = [];
        let sortedDates = [];
        let minDateIndex = 0;
        let maxDateIndex = 0;

        // Function to parse CSV data
        async function loadCSVData() {
            try {
                const response = await fetch('properties.csv');
                const csvData = await response.text();
                
                Papa.parse(csvData, {
                    header: true,
                    complete: function(results) {
                        console.log(results.data);
                        allProperties = results.data.filter(prop => prop.url); // Filter out empty rows
                        buildDateHistogram(); // Build histogram after data is loaded
                        updateFilterCounts();
                        
                        // Delay initial filtering to ensure map is fully positioned
                        setTimeout(() => {
                            applyFilters(); // Use applyFilters instead of direct calls
                        }, 100);
                        const loadingElement = document.getElementById('loading');
                        if (loadingElement) {
                            loadingElement.style.display = 'none';
                        }
                    },
                    error: function(error) {
                        console.error('Error parsing CSV:', error);
                        const loadingElement = document.getElementById('loading');
                        if (loadingElement) {
                            loadingElement.textContent = 'Error loading data';
                        }
                    }
                });
            } catch (error) {
                console.error('Error fetching CSV:', error);
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.textContent = 'Error loading data';
                }
            }
        }

        // Function to display properties on the map
        function displayProperties(properties) {
            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            
            properties.forEach((property, index) => {
                // Skip properties without coordinates
                if (!property.coordinates) return;
                
                try {
                    // Parse coordinates (expected format: "lat,lng")
                    const coords = property.coordinates.split(',').map(coord => parseFloat(coord.trim()));
                    
                    if (coords.length !== 2 || isNaN(coords[0]) || isNaN(coords[1])) {
                        console.warn('Invalid coordinates for property:', property);
                        return;
                    }
                    
                    // Choose marker color based on listing type
                    let markerColor = '#28a745'; // default green for available
                    if (property.listing_type === 'sold') {
                        markerColor = '#ff0000'; // red for sold
                    } else if (property.listing_type === 'unavailable') {
                        markerColor = '#6c757d'; // gray for unavailable
                    }
                    
                    // Create lightweight CircleMarker (hardware accelerated)
                    const marker = L.circleMarker([coords[0], coords[1]], {
                        radius: 8,
                        fillColor: markerColor,
                        color: 'white',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map);
                    
                    // Store property reference with marker
                    marker.propertyData = property;
                    
                    // Add click handler for marker highlighting (same behavior for all devices)
                    marker.on('click', function() {
                        highlightProperty(property);
                        highlightMarker(property);
                    });
                    
                    // Add interactive popup
                    const leanPopupContent = createLeanPopupContent(property);
                    marker.bindTooltip(leanPopupContent, {
                        permanent: false,
                        direction: 'top',
                        offset: [0, -10],
                        className: 'lean-popup',
                        interactive: true
                    });
                    
                    // Add click event to tooltip when it opens
                    marker.on('tooltipopen', function(e) {
                        const tooltipEl = e.tooltip.getElement();
                        if (tooltipEl) {
                            tooltipEl.style.cursor = 'pointer';
                            
                            // Add multiple event listeners for better mobile compatibility
                            let touchStartTime = 0;
                            let touchStartPos = { x: 0, y: 0 };
                            
                            const handleTouchStart = function(event) {
                                touchStartTime = Date.now();
                                const touch = event.touches[0];
                                touchStartPos = { x: touch.clientX, y: touch.clientY };
                            };
                            
                            const handleTouchEnd = function(event) {
                                const touchDuration = Date.now() - touchStartTime;
                                const touch = event.changedTouches[0];
                                const touchEndPos = { x: touch.clientX, y: touch.clientY };
                                const distance = Math.sqrt(
                                    Math.pow(touchEndPos.x - touchStartPos.x, 2) + 
                                    Math.pow(touchEndPos.y - touchStartPos.y, 2)
                                );
                                
                                // Only treat as tap if it's quick and didn't move much
                                if (touchDuration < 300 && distance < 10) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                    openListPanelWithProperty(property);
                                }
                            };
                            
                            const handleClick = function(event) {
                                event.stopPropagation();
                                openListPanelWithProperty(property);
                            };
                            
                            tooltipEl.addEventListener('click', handleClick);
                            tooltipEl.addEventListener('touchstart', handleTouchStart, { passive: true });
                            tooltipEl.addEventListener('touchend', handleTouchEnd, { passive: false });
                            
                            // Store the handlers for cleanup
                            tooltipEl._clickHandler = handleClick;
                            tooltipEl._touchStartHandler = handleTouchStart;
                            tooltipEl._touchEndHandler = handleTouchEnd;
                        }
                    });
                    
                    // Clean up event listeners when tooltip closes
                    marker.on('tooltipclose', function(e) {
                        const tooltipEl = e.tooltip.getElement();
                        if (tooltipEl) {
                            if (tooltipEl._clickHandler) {
                                tooltipEl.removeEventListener('click', tooltipEl._clickHandler);
                                delete tooltipEl._clickHandler;
                            }
                            if (tooltipEl._touchStartHandler) {
                                tooltipEl.removeEventListener('touchstart', tooltipEl._touchStartHandler);
                                delete tooltipEl._touchStartHandler;
                            }
                            if (tooltipEl._touchEndHandler) {
                                tooltipEl.removeEventListener('touchend', tooltipEl._touchEndHandler);
                                delete tooltipEl._touchEndHandler;
                            }
                        }
                    });
                    
                    // Store marker for filtering
                    markers.push(marker);
                } catch (error) {
                    console.warn('Error processing property:', property, error);
                }
            });
        }

        // Function to create lean popup content for hover
        function createLeanPopupContent(property) {
            const priceInfo = formatPriceWithSqmPrice(property);
            const title = property.name || property.location;
            const truncatedTitle = truncateTitle(title, 80);
            return `
                <div class="popup-price">${priceInfo}</div>
                <div class="popup-location" style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; word-wrap: break-word; line-height: 1.3;">${truncatedTitle}</div>
                <div class="popup-type">${formatPropertyType(property.property_type)}</div>
                ${property.date ? `<div style="color: #666; font-size: 0.85em; margin-top: 2px;">${property.date}</div>` : ''}
                <div class="popup-tap-hint">Click to view details</div>
            `;
        }

        // Function to create popup content
        function createPopupContent(property) {
            const container = document.createElement('div');
            container.className = 'info-container';
            
            // Title
            const title = document.createElement('div');
            title.className = 'info-title';
            title.textContent = property.name || `${property.location} - ${formatPropertyType(property.property_type)}`;
            container.appendChild(title);
            
            // Listing Type
            if (property.listing_type) {
                const listingType = document.createElement('div');
                listingType.className = `info-listing-type listing-type-${property.listing_type}`;
                listingType.textContent = property.listing_type.charAt(0).toUpperCase() + property.listing_type.slice(1);
                container.appendChild(listingType);
            }
            
            // Price
            if (property.price) {
                const price = document.createElement('div');
                price.className = 'info-price';
                price.textContent = property.price;
                container.appendChild(price);
            }
            
            // Date
            if (property.date) {
                const date = document.createElement('div');
                date.className = 'info-date';
                date.textContent = property.date;
                container.appendChild(date);
            }
            
            // Address
            if (property.address) {
                const address = document.createElement('div');
                address.className = 'info-address';
                address.textContent = property.address;
                container.appendChild(address);
            }
            
            // Visit button
            const visitButton = document.createElement('button');
            visitButton.className = 'visit-button';
            visitButton.textContent = 'Visit Property Page';
            visitButton.onclick = function(e) {
                e.stopPropagation();
                window.open(property.url, '_blank');
            };
            container.appendChild(visitButton);
            
            return container;
        }

        // Function to update filter counts
        function updateFilterCounts() {
            // Count total properties by category
            const totalAvailable = allProperties.filter(p => p.listing_type === 'available').length;
            const totalSold = allProperties.filter(p => p.listing_type === 'sold').length;
            const totalUnavailable = allProperties.filter(p => p.listing_type === 'unavailable').length;
            const totalApartment = allProperties.filter(p => p.property_type === 'apartment').length;
            const totalHouse = allProperties.filter(p => p.property_type === 'house').length;
            const totalLand = allProperties.filter(p => p.property_type === 'land').length;
            const totalUnknown = allProperties.filter(p => p.property_type === 'unknown').length;
            
            // Count visible properties by category (from displayedProperties - what's actually shown in the list)
            const visibleAvailable = displayedProperties.filter(p => p.listing_type === 'available').length;
            const visibleSold = displayedProperties.filter(p => p.listing_type === 'sold').length;
            const visibleUnavailable = displayedProperties.filter(p => p.listing_type === 'unavailable').length;
            const visibleApartment = displayedProperties.filter(p => p.property_type === 'apartment').length;
            const visibleHouse = displayedProperties.filter(p => p.property_type === 'house').length;
            const visibleLand = displayedProperties.filter(p => p.property_type === 'land').length;
            const visibleUnknown = displayedProperties.filter(p => p.property_type === 'unknown').length;
            
            // Update counts in visible/total format
            document.getElementById('available-count').textContent = `(${visibleAvailable}/${totalAvailable})`;
            document.getElementById('sold-count').textContent = `(${visibleSold}/${totalSold})`;
            document.getElementById('unavailable-count').textContent = `(${visibleUnavailable}/${totalUnavailable})`;
            document.getElementById('apartment-count').textContent = `(${visibleApartment}/${totalApartment})`;
            document.getElementById('house-count').textContent = `(${visibleHouse}/${totalHouse})`;
            document.getElementById('land-count').textContent = `(${visibleLand}/${totalLand})`;
            document.getElementById('unknown-count').textContent = `(${visibleUnknown}/${totalUnknown})`;
        }

        // Function to display properties in the list
        function displayPropertyList(properties) {
            const listContainer = document.getElementById('property-list');
            listContainer.innerHTML = '';
            propertyElements = []; // Clear previous property elements
            displayedProperties = properties; // Track currently displayed properties
            
            // Update the count in the sidebar header
            const propertyCountElement = document.getElementById('property-count');
            if (propertyCountElement) {
                propertyCountElement.textContent = `${properties.length} out of ${allProperties.length} properties`;
            }
            
            // Handle empty results
            if (properties.length === 0) {
                listContainer.innerHTML = '<div class="loading">No properties match the current filters</div>';
                return;
            }
            
            // Sort properties by date (newest first)
            const sortedProperties = properties.slice().sort((a, b) => {
                const dateA = a.date ? new Date(a.date) : new Date(0);
                const dateB = b.date ? new Date(b.date) : new Date(0);
                return dateB - dateA; // Newest first
            });
            
            sortedProperties.forEach(property => {
                const propertyDiv = document.createElement('div');
                propertyDiv.className = `property-item ${property.listing_type}`;
                propertyDiv.propertyData = property; // Store property reference
                
                const sizeInfo = createSizeInfoLine(property);
                
                propertyDiv.innerHTML = `
                    <div class="property-header">
                        <div class="property-title">${property.name || `${property.location} - ${formatPropertyType(property.property_type)}`}</div>
                        <a href="${property.url}" target="_blank" class="details-button" onclick="event.stopPropagation();">
                            Details
                        </a>
                    </div>
                    <div class="property-location">${property.address || property.location}</div>
                    <div class="property-price">${formatPriceWithSqmPrice(property)}</div>
                    ${sizeInfo}
                    <div class="property-stats">
                        <span class="info-listing-type listing-type-${property.listing_type}">
                            ${property.listing_type.charAt(0).toUpperCase() + property.listing_type.slice(1)}
                        </span>
                        ${property.date ? `<span>${property.date}</span>` : ''}
                    </div>
                `;
                
                // Add click handler for highlighting
                propertyDiv.addEventListener('click', (e) => {
                    // Check if this property is already highlighted
                    if (propertyDiv.classList.contains('highlighted')) {
                        // If already highlighted, close the panel
                        closeSidebar();
                    } else {
                        // If not highlighted, highlight it
                        highlightProperty(property);
                        highlightMarker(property);
                    }
                });
                
                propertyElements.push(propertyDiv);
                listContainer.appendChild(propertyDiv);
            });
        }
        
        // Helper function to format price
        function formatPrice(price) {
            if (!price) return 'Price not available';
            const numPrice = parseInt(price);
            if (isNaN(numPrice)) return price;
            return `€${numPrice.toLocaleString()}`;
        }

        // Helper function to format price with three-column layout
        function formatPriceWithSqmPrice(property) {
            if (!property.price) return 'Price not available';
            
            const numPrice = parseInt(property.price);
            if (isNaN(numPrice)) return property.price;
            
            const formattedPrice = `€${numPrice.toLocaleString()}`;
            
            // Calculate living price per sqm
            let livingPricePerSqm = '';
            if (property.size_living) {
                const livingMatch = property.size_living.match(/(\d+(?:[.,]\d+)?)/);
                if (livingMatch) {
                    const livingSize = parseFloat(livingMatch[1].replace(',', '.'));
                    if (livingSize > 0) {
                        const livingSqmPrice = Math.round(numPrice / livingSize);
                        livingPricePerSqm = `€${livingSqmPrice.toLocaleString()}/m²`;
                    }
                }
            }
            
            // Calculate ground price per sqm
            let groundPricePerSqm = '';
            if (property.size_ground) {
                const groundMatch = property.size_ground.match(/(\d+(?:[.,]\d+)?)/);
                if (groundMatch) {
                    const groundSize = parseFloat(groundMatch[1].replace(',', '.'));
                    if (groundSize > 0) {
                        const groundSqmPrice = Math.round(numPrice / groundSize);
                        groundPricePerSqm = `€${groundSqmPrice.toLocaleString()}/m²`;
                    }
                }
            }
            
            // Create three-column layout
            return `
                <div style="display: flex; justify-content: space-between; align-items: baseline; gap: 8px;">
                    <span style="color: #2c8a2c; font-weight: bold; font-size: 1em; flex: 1; text-align: left;">${formattedPrice}</span>
                    ${livingPricePerSqm ? `<span style="color: #666; font-weight: bold; font-size: 1em; flex: 1; text-align: center;">${livingPricePerSqm}</span>` : '<span style="flex: 1;"></span>'}
                    ${groundPricePerSqm ? `<span style="color: #666; font-weight: bold; font-size: 1em; flex: 1; text-align: right;">${groundPricePerSqm}</span>` : '<span style="flex: 1;"></span>'}
                </div>
            `;
        }

        // Helper function to convert property type to German label
        function formatPropertyType(propertyType) {
            switch (propertyType) {
                case 'apartment': return 'Wohnung';
                case 'house': return 'Haus';
                case 'land': return 'Grundstück';
                case 'unknown': return 'Unbekannt';
                default: return propertyType;
            }
        }

        // Helper function to truncate title with ellipsis
        function truncateTitle(title, maxLength) {
            if (!title || title.length <= maxLength) return title;
            return title.substring(0, maxLength).trim() + '...';
        }

        // Helper function to create size info line for cards
        function createSizeInfoLine(property) {
            const hasLivingSize = property.size_living;
            const hasGroundSize = property.size_ground;
            
            // Skip the line if both sizes are not available
            if (!hasLivingSize && !hasGroundSize) {
                return '';
            }
            
            return `
                <div style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 5px; color: #666; font-size: 0.9em;">
                    <span style="flex: 1;"></span>
                    ${hasLivingSize ? `<span style="flex: 1; text-align: center;">${property.size_living}${property.size_living.includes('m²') ? '' : ' m²'}</span>` : '<span style="flex: 1;"></span>'}
                    ${hasGroundSize ? `<span style="flex: 1; text-align: right;">${property.size_ground}${property.size_ground.includes('m²') ? '' : ' m²'}</span>` : '<span style="flex: 1;"></span>'}
                </div>
            `;
        }

        // Function to build date histogram from specific properties
        function buildDateHistogram(properties = null) {
            // Use provided properties, or fall back to allProperties for initial load
            const propertiesForHistogram = properties || allProperties;
            
            // Collect all valid dates from properties, filtering out invalid dates
            const dates = [];
            const today = new Date();
            const earliestValidDate = new Date('2000-01-01'); // Reasonable earliest date
            
            propertiesForHistogram.forEach(property => {
                if (property.date && property.date.trim() !== '') {
                    const date = new Date(property.date);
                    // Filter out invalid dates and dates that are clearly wrong
                    if (!isNaN(date.getTime()) && 
                        date >= earliestValidDate && 
                        date <= today) {
                        dates.push(date);
                    }
                }
            });
            
            if (dates.length === 0) {
                // No valid dates available, hide the date filter
                const filterGroup = document.querySelector('.filter-group');
                if (filterGroup && filterGroup.querySelector('#date-histogram')) {
                    filterGroup.style.display = 'none';
                }
                return;
            }
            
            // Sort dates and create sorted array
            sortedDates = dates.sort((a, b) => a - b);
            const minDate = sortedDates[0];
            let maxDate = sortedDates[sortedDates.length - 1];
            
            // Ensure today is always the maximum date (rightmost)
            if (maxDate < today) {
                maxDate = today;
            }
            
            // Create monthly buckets for histogram, ensuring we cover from minDate to today
            const monthBuckets = {};
            
            // Add all property dates to buckets
            sortedDates.forEach(date => {
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                monthBuckets[monthKey] = (monthBuckets[monthKey] || 0) + 1;
            });
            
            // Create continuous range from min date to today
            const startDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
            const endDate = new Date(today.getFullYear(), today.getMonth(), 1);
            
            dateHistogramData = [];
            const currentDate = new Date(startDate);
            
            while (currentDate <= endDate) {
                const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
                dateHistogramData.push({
                    month: monthKey,
                    count: monthBuckets[monthKey] || 0, // 0 if no properties in this month
                    date: new Date(currentDate)
                });
                currentDate.setMonth(currentDate.getMonth() + 1);
            }
            
            // Initialize slider to full range
            maxDateIndex = dateHistogramData.length - 1;
            
            // Build the histogram visualization
            renderDateHistogram();
            updateDateLabels();
            updateSliderRangeFill();
            
            // Update slider ranges after histogram is built
            if (window.updateSliderRanges) {
                window.updateSliderRanges();
            }
        }
        
        // Function to render the histogram bars
        function renderDateHistogram() {
            const histogramContainer = document.getElementById('date-histogram');
            histogramContainer.innerHTML = '';
            
            if (dateHistogramData.length === 0) return;
            
            const maxCount = Math.max(...dateHistogramData.map(d => d.count));
            const containerWidth = histogramContainer.clientWidth || 280;
            const barWidth = Math.max((containerWidth / dateHistogramData.length) - 1, 1);
            
            dateHistogramData.forEach((data, index) => {
                const bar = document.createElement('div');
                bar.className = 'histogram-bar';
                bar.style.left = `${(index * (containerWidth / dateHistogramData.length))}px`;
                bar.style.width = `${barWidth}px`;
                
                // Ensure bars with no data are still visible but very small
                const height = data.count === 0 ? 1 : Math.max((data.count / maxCount) * 50, 2);
                bar.style.height = `${height}px`;
                
                // Set data attribute for count (used in highlighting)
                bar.setAttribute('data-count', data.count.toString());
                
                // Set tooltip
                if (data.count === 0) {
                    bar.title = `${data.month}: No properties`;
                } else {
                    bar.title = `${data.month}: ${data.count} ${data.count === 1 ? 'property' : 'properties'}`;
                }
                
                histogramContainer.appendChild(bar);
            });
            
            // Update histogram based on current selection
            updateHistogramSelection();
        }
        
        // Function to update histogram bar highlighting
        function updateHistogramSelection() {
            const bars = document.querySelectorAll('.histogram-bar');
            
            // Debug info
            console.log(`Updating histogram selection: minIndex=${minDateIndex}, maxIndex=${maxDateIndex}, bars=${bars.length}`);
            
            bars.forEach((bar, index) => {
                // Clear any existing classes
                bar.classList.remove('dimmed', 'empty-month', 'selected');
                
                // Determine the appropriate styling
                const isEmpty = bar.getAttribute('data-count') === '0';
                const isSelected = index >= minDateIndex && index <= maxDateIndex;
                
                if (isSelected) {
                    if (isEmpty) {
                        bar.classList.add('empty-month');
                    } else {
                        bar.classList.add('selected');
                    }
                } else {
                    bar.classList.add('dimmed');
                }
            });
        }
        
        // Function to update the visual range fill between sliders
        function updateSliderRangeFill() {
            const rangeFill = document.getElementById('slider-range-fill');
            if (!rangeFill || dateHistogramData.length === 0) return;
            
            const containerWidth = document.getElementById('date-slider-container').offsetWidth || 280;
            const totalRange = Math.max(1, dateHistogramData.length - 1);
            
            const startPercent = (minDateIndex / totalRange) * 100;
            const endPercent = (maxDateIndex / totalRange) * 100;
            const widthPercent = endPercent - startPercent;
            
            rangeFill.style.left = `${startPercent}%`;
            rangeFill.style.width = `${widthPercent}%`;
        }
        
        // Function to update date range labels
        function updateDateLabels() {
            const startLabel = document.getElementById('date-range-start');
            const endLabel = document.getElementById('date-range-end');
            const clearButton = document.getElementById('clear-dates');
            
            if (dateHistogramData.length === 0) {
                startLabel.textContent = 'No dates';
                endLabel.textContent = 'No dates';
                clearButton.style.display = 'none';
                return;
            }
            
            const isFullRange = minDateIndex === 0 && maxDateIndex === dateHistogramData.length - 1;
            
            if (isFullRange) {
                startLabel.textContent = 'All';
                endLabel.textContent = 'All';
                clearButton.style.display = 'none';
            } else {
                // Ensure indices are within bounds
                const safeMinIndex = Math.max(0, Math.min(minDateIndex, dateHistogramData.length - 1));
                const safeMaxIndex = Math.max(0, Math.min(maxDateIndex, dateHistogramData.length - 1));
                
                const startDate = dateHistogramData[safeMinIndex].date;
                const endDate = dateHistogramData[safeMaxIndex].date;
                
                try {
                    startLabel.textContent = startDate.toLocaleDateString('en-GB', { month: 'short', year: 'numeric' });
                    endLabel.textContent = endDate.toLocaleDateString('en-GB', { month: 'short', year: 'numeric' });
                } catch (error) {
                    console.warn('Date formatting error:', error);
                    startLabel.textContent = 'Invalid';
                    endLabel.textContent = 'Invalid';
                }
                clearButton.style.display = 'inline-block';
            }
        }

        // Function to update histogram for specific set of properties
        function updateHistogramForProperties(properties) {
            // Save current slider positions and check if range was at full extent
            const currentMinIndex = minDateIndex;
            const currentMaxIndex = maxDateIndex;
            const oldLength = dateHistogramData.length;
            const wasFullRange = (currentMinIndex === 0 && currentMaxIndex === oldLength - 1);
            
            // Build new histogram
            buildDateHistogram(properties);
            
            // Handle slider positioning after histogram rebuild
            if (dateHistogramData.length > 0) {
                if (wasFullRange || oldLength === 0) {
                    // If the range was at full extent or this is the first build, keep it at full extent
                    minDateIndex = 0;
                    maxDateIndex = dateHistogramData.length - 1;
                } else {
                    // Keep proportional position if range was restricted
                    const minRatio = oldLength > 1 ? currentMinIndex / Math.max(1, oldLength - 1) : 0;
                    const maxRatio = oldLength > 1 ? currentMaxIndex / Math.max(1, oldLength - 1) : 1;
                    
                    minDateIndex = Math.floor(minRatio * (dateHistogramData.length - 1));
                    maxDateIndex = Math.floor(maxRatio * (dateHistogramData.length - 1));
                    
                    // Ensure valid bounds
                    minDateIndex = Math.max(0, Math.min(minDateIndex, dateHistogramData.length - 1));
                    maxDateIndex = Math.max(minDateIndex, Math.min(maxDateIndex, dateHistogramData.length - 1));
                }
            }
        }

        // Function to update histogram bar heights without changing date bounds
        function updateHistogramBarsOnly(properties) {
            // If histogram hasn't been built yet, build it normally
            if (dateHistogramData.length === 0) {
                updateHistogramForProperties(properties);
                return;
            }
            
            // Count properties for each existing month bucket
            const monthCounts = {};
            const today = new Date();
            const earliestValidDate = new Date('2000-01-01');
            
            properties.forEach(property => {
                if (property.date && property.date.trim() !== '') {
                    const date = new Date(property.date);
                    if (!isNaN(date.getTime()) && 
                        date >= earliestValidDate && 
                        date <= today) {
                        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        monthCounts[monthKey] = (monthCounts[monthKey] || 0) + 1;
                    }
                }
            });
            
            // Update existing histogram data counts
            dateHistogramData.forEach(data => {
                const monthKey = `${data.date.getFullYear()}-${String(data.date.getMonth() + 1).padStart(2, '0')}`;
                data.count = monthCounts[monthKey] || 0;
            });
            
            // Re-render the histogram bars with new counts
            renderDateHistogram();
            updateHistogramSelection();
        }

        // Debounced filter function for date range changes
        let filterDebounceTimer = null;
        function debouncedApplyFilters() {
            clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyFilters();
            }, 500);
        }

        // Debounced filter function for map pan/zoom changes
        let mapFilterDebounceTimer = null;
        function debouncedMapFilters() {
            clearTimeout(mapFilterDebounceTimer);
            mapFilterDebounceTimer = setTimeout(() => {
                applyFilters();
            }, 250);
        }

        // Function to apply filters
        function applyFilters() {
            const showAvailable = document.getElementById('filter-available').checked;
            const showSold = document.getElementById('filter-sold').checked;
            const showUnavailable = document.getElementById('filter-unavailable').checked;
            const showApartment = document.getElementById('filter-apartment').checked;
            const showHouse = document.getElementById('filter-house').checked;
            const showLand = document.getElementById('filter-land').checked;
            const showUnknown = document.getElementById('filter-unknown').checked;
            
            // Save filter settings to local storage
            saveFilterSettings();
            
            // First, apply non-date filters to get base set
            let baseFilteredProperties = allProperties.filter(property => {
                // Filter by listing type
                if (property.listing_type === 'available' && !showAvailable) return false;
                if (property.listing_type === 'sold' && !showSold) return false;
                if (property.listing_type === 'unavailable' && !showUnavailable) return false;
                
                // Filter by property type
                if (property.property_type === 'apartment' && !showApartment) return false;
                if (property.property_type === 'house' && !showHouse) return false;
                if (property.property_type === 'land' && !showLand) return false;
                if (property.property_type === 'unknown' && !showUnknown) return false;
                
                return true;
            });
            
            // Apply map visibility filter if enabled
            if (showOnlyVisible && map) {
                const bounds = map.getBounds();
                baseFilteredProperties = baseFilteredProperties.filter(property => {
                    if (!property.coordinates) return false;
                    const coords = property.coordinates.split(',').map(coord => parseFloat(coord.trim()));
                    if (coords.length !== 2 || isNaN(coords[0]) || isNaN(coords[1])) return false;
                    return bounds.contains([coords[0], coords[1]]);
                });
            }
            
            // Update histogram bars based on visible properties, but keep date bounds stable
            updateHistogramBarsOnly(baseFilteredProperties);
            
            // Get date filter range from updated histogram slider
            const hasDateFilter = minDateIndex > 0 || maxDateIndex < dateHistogramData.length - 1;
            let startDate = null;
            let endDate = null;
            
            if (hasDateFilter && dateHistogramData.length > 0) {
                startDate = dateHistogramData[minDateIndex].date;
                endDate = new Date(dateHistogramData[maxDateIndex].date);
                endDate.setMonth(endDate.getMonth() + 1); // End of selected month
                endDate.setDate(0); // Last day of previous month (i.e., last day of selected month)
                endDate.setHours(23, 59, 59, 999); // End of day
            }
            
            // Now apply date filters to get final result
            filteredProperties = baseFilteredProperties.filter(property => {
                // Filter by date range from histogram slider
                if (hasDateFilter) {
                    if (property.date) {
                        const propertyDate = new Date(property.date);
                        
                        if (startDate && propertyDate < startDate) return false;
                        if (endDate && propertyDate > endDate) return false;
                    } else {
                        // If property has no date and date filter is active, exclude it
                        return false;
                    }
                }
                
                return true;
            });
            
            displayProperties(filteredProperties);
            displayPropertyList(filteredProperties);
            
            // Update filter counts to show visible/total
            updateFilterCounts();
        }
        
        // Function to filter list to only show properties with visible markers
        function filterListByVisibleMarkers() {
            const bounds = map.getBounds();
            let visibleProperties = filteredProperties.filter(property => {
                if (!property.coordinates) return false;
                const coords = property.coordinates.split(',').map(coord => parseFloat(coord.trim()));
                if (coords.length !== 2 || isNaN(coords[0]) || isNaN(coords[1])) return false;
                return bounds.contains([coords[0], coords[1]]);
            });
            
            // Store the currently highlighted property data for re-highlighting
            let highlightedPropertyData = null;
            if (currentHighlightedProperty && currentHighlightedProperty.propertyData) {
                highlightedPropertyData = currentHighlightedProperty.propertyData;
                const isAlreadyIncluded = visibleProperties.some(p => p.url === highlightedPropertyData.url);
                if (!isAlreadyIncluded) {
                    // Add highlighted property to the beginning of the list
                    visibleProperties.unshift(highlightedPropertyData);
                }
            }
            
            displayPropertyList(visibleProperties);
            
            // Update filter counts to reflect what's actually displayed
            updateFilterCounts();
            
            // Re-establish highlighting after the list is rebuilt
            if (highlightedPropertyData) {
                reHighlightProperty(highlightedPropertyData);
            }
        }
        
        // Function to re-establish property highlighting after list rebuild
        function reHighlightProperty(propertyData) {
            // Find the new property element in the rebuilt list
            const propertyElement = propertyElements.find(el => el.propertyData && el.propertyData.url === propertyData.url);
            if (propertyElement) {
                propertyElement.classList.add('highlighted');
                currentHighlightedProperty = propertyElement;
                
                // Scroll to the highlighted property
                propertyElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }
        }
        
        // Function to reset view and show all properties
        function resetView() {
            showOnlyVisible = false;
            clearHighlights();
            map.setView([47.2499, 9.9809], 10); // Reset to initial Vorarlberg view
            // Save the reset position to local storage
            saveMapPosition(47.2499, 9.9809, 10);
            
            // Reset all filters to checked state
            document.getElementById('filter-available').checked = true;
            document.getElementById('filter-sold').checked = true;
            document.getElementById('filter-unavailable').checked = true;
            document.getElementById('filter-apartment').checked = true;
            document.getElementById('filter-house').checked = true;
            document.getElementById('filter-land').checked = true;
            document.getElementById('filter-unknown').checked = true;
            
            // Reset date histogram range
            minDateIndex = 0;
            maxDateIndex = Math.max(0, dateHistogramData.length - 1);
            if (window.updateSliderRanges) {
                window.updateSliderRanges();
            }
            updateHistogramSelection();
            updateDateLabels();
            updateSliderRangeFill();
            
            applyFilters(); // Refresh the display
        }

        // Function to highlight a property in the list when its marker is clicked
        function highlightProperty(property) {
            // Log property data to console
            console.table(property);
            
            // On desktop, auto-switch to list view when sidebar is open
            if (window.innerWidth > 768 && !sidebarCollapsed) {
                showPanel('list');
            }
            
            // Clear previous property highlighting
            if (currentHighlightedProperty) {
                currentHighlightedProperty.classList.remove('highlighted');
            }
            
            // Find the property element with matching data
            const propertyElement = propertyElements.find(el => el.propertyData && el.propertyData.url === property.url);
            if (propertyElement) {
                propertyElement.classList.add('highlighted');
                currentHighlightedProperty = propertyElement;
                
                // Scroll the highlighted property into view
                propertyElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            } else {
                console.log('Property element not found for:', property.url);
            }
        }

        // Function to highlight a marker when its property list item is clicked
        function highlightMarker(property) {
            // Clear previous marker highlighting by restoring original style
            if (currentHighlightedMarker) {
                let originalColor = '#28a745'; // default green for available
                if (currentHighlightedMarker.propertyData.listing_type === 'sold') {
                    originalColor = '#ff0000'; // red for sold
                } else if (currentHighlightedMarker.propertyData.listing_type === 'unavailable') {
                    originalColor = '#6c757d'; // gray for unavailable
                }
                currentHighlightedMarker.setStyle({
                    radius: 8,
                    fillColor: originalColor,
                    color: 'white',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                });
            }
            
            // Find the marker with matching property data
            const marker = markers.find(m => m.propertyData && m.propertyData.url === property.url);
            
            if (marker) {
                // Highlight the marker by increasing size and changing border
                let markerColor = '#28a745'; // default green for available
                if (marker.propertyData.listing_type === 'sold') {
                    markerColor = '#ff0000'; // red for sold
                } else if (marker.propertyData.listing_type === 'unavailable') {
                    markerColor = '#6c757d'; // gray for unavailable
                }
                marker.setStyle({
                    radius: 10,
                    fillColor: markerColor,
                    color: '#ffc107', // Yellow border for highlighting
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 1
                });
                currentHighlightedMarker = marker;
                
                // Center map on the marker (only when called from list click)
                if (marker !== currentHighlightedMarker || !document.querySelector('.property-item.highlighted')) {
                    map.setView(marker.getLatLng(), Math.max(map.getZoom(), 15), {
                        animate: true,
                        duration: 0.5
                    });
                }
            }
        }

        // Function to clear all highlights
        function clearHighlights() {
            // Clear property highlighting
            if (currentHighlightedProperty) {
                currentHighlightedProperty.classList.remove('highlighted');
                currentHighlightedProperty = null;
            }
            
            // Clear marker highlighting
            if (currentHighlightedMarker) {
                let originalColor = '#28a745'; // default green for available
                if (currentHighlightedMarker.propertyData.listing_type === 'sold') {
                    originalColor = '#ff0000'; // red for sold
                } else if (currentHighlightedMarker.propertyData.listing_type === 'unavailable') {
                    originalColor = '#6c757d'; // gray for unavailable
                }
                currentHighlightedMarker.setStyle({
                    radius: 8,
                    fillColor: originalColor,
                    color: 'white',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                });
                currentHighlightedMarker = null;
            }
        }

        // Add ESC key listener to clear highlights
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                clearHighlights();
            }
        });

        // Add map event listeners for automatic visible filtering and position saving
        map.on('moveend zoomend', function() {
            // Save current map position to local storage
            const center = map.getCenter();
            const zoom = map.getZoom();
            saveMapPosition(center.lat, center.lng, zoom);
            
            if (showOnlyVisible) {
                // Re-apply all filters including the new map bounds (debounced)
                debouncedMapFilters();
            }
        });

        // Enable visible filtering when user interacts with map
        map.on('dragstart zoomstart', function() {
            if (!showOnlyVisible) {
                showOnlyVisible = true;
                saveFilterSettings(); // Save the change in visible mode
            }
        });

        // Sidebar toggle functionality
        // Initialize sidebar state from local storage or default to collapsed
        const storedPanelState = getStoredPanelState();
        let sidebarCollapsed = storedPanelState ? storedPanelState.sidebarCollapsed : true;
        
        function openSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mapElement = document.getElementById('map');
            const listToggle = document.querySelector('.list-toggle');
            const filterToggle = document.querySelector('.filter-toggle');
            
            sidebarCollapsed = false;
            sidebar.classList.remove('collapsed');
            mapElement.classList.add('sidebar-open');
            listToggle.classList.remove('collapsed');
            filterToggle.classList.remove('collapsed');
            
            // Save panel state to local storage
            savePanelState();
            
            // Trigger map resize after animation completes
            setTimeout(() => {
                map.invalidateSize();
            }, 350);
        }
        
        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mapElement = document.getElementById('map');
            const listToggle = document.querySelector('.list-toggle');
            const filterToggle = document.querySelector('.filter-toggle');
            
            sidebarCollapsed = true;
            sidebar.classList.add('collapsed');
            mapElement.classList.remove('sidebar-open');
            listToggle.classList.add('collapsed');
            filterToggle.classList.add('collapsed');
            
            // Save panel state to local storage
            savePanelState();
            
            // Trigger map resize after animation completes
            setTimeout(() => {
                map.invalidateSize();
            }, 350);
        }
        
        // Panel switching functionality
        function showPanel(panelType) {
            const listTab = document.getElementById('list-tab');
            const filterTab = document.getElementById('filter-tab');
            const propertyPanel = document.getElementById('property-panel');
            const filterPanel = document.getElementById('filter-panel');
            
            if (panelType === 'list') {
                listTab.classList.add('active');
                filterTab.classList.remove('active');
                propertyPanel.classList.add('active');
                filterPanel.classList.remove('active');
            } else if (panelType === 'filter') {
                listTab.classList.remove('active');
                filterTab.classList.add('active');
                propertyPanel.classList.remove('active');
                filterPanel.classList.add('active');
            }
        }
        
        // List toggle functionality (quick access to properties list)
        function toggleListPanel() {
            if (sidebarCollapsed) {
                openSidebar();
            }
            showPanel('list');
        }
        
        // Filter toggle functionality (quick access to filter panel)
        function toggleFilterPanel() {
            if (sidebarCollapsed) {
                openSidebar();
            }
            showPanel('filter');
        }
        
        // Open list panel with specific property highlighted (for mobile popup tap)
        function openListPanelWithProperty(property) {
            if (sidebarCollapsed) {
                openSidebar();
            }
            showPanel('list');
            
            // Highlight the property after a short delay to ensure panel is open
            setTimeout(() => {
                highlightProperty(property);
                highlightMarker(property);
            }, 100);
        }

        // Function to restore filter settings from local storage
        function restoreFilterSettings() {
            const storedSettings = getStoredFilterSettings();
            if (storedSettings) {
                document.getElementById('filter-available').checked = storedSettings.available;
                document.getElementById('filter-sold').checked = storedSettings.sold;
                if (storedSettings.unavailable !== undefined) {
                    document.getElementById('filter-unavailable').checked = storedSettings.unavailable;
                }
                document.getElementById('filter-apartment').checked = storedSettings.apartment;
                document.getElementById('filter-house').checked = storedSettings.house;
                document.getElementById('filter-land').checked = storedSettings.land;
                document.getElementById('filter-unknown').checked = storedSettings.unknown;
                
                // Restore date histogram range if it exists
                if (storedSettings.dateMinIndex !== undefined && storedSettings.dateMaxIndex !== undefined) {
                    minDateIndex = storedSettings.dateMinIndex;
                    maxDateIndex = storedSettings.dateMaxIndex;
                    // Update will happen when histogram is built
                }
                
                // Restore showOnlyVisible state
                if (storedSettings.showOnlyVisible !== undefined) {
                    showOnlyVisible = storedSettings.showOnlyVisible;
                }
            }
        }

        // Add automatic filter event listeners
        function setupFilterListeners() {
            const filterIds = [
                'filter-available', 'filter-sold', 'filter-unavailable',
                'filter-apartment', 'filter-house', 'filter-land', 'filter-unknown'
            ];
            
            filterIds.forEach(filterId => {
                const checkbox = document.getElementById(filterId);
                if (checkbox) {
                    checkbox.addEventListener('change', applyFilters);
                }
            });
            
            // Add event listeners for date histogram slider
            const minSlider = document.getElementById('date-slider-min');
            const maxSlider = document.getElementById('date-slider-max');
            const clearDatesBtn = document.getElementById('clear-dates');
            
            if (minSlider && maxSlider) {
                // Update slider ranges when histogram is built
                function updateSliderRanges() {
                    const maxRange = Math.max(0, dateHistogramData.length - 1);
                    minSlider.max = maxRange;
                    maxSlider.max = maxRange;
                    minSlider.value = minDateIndex;
                    maxSlider.value = maxDateIndex;
                }
                
                // Handle slider changes
                function handleSliderChange() {
                    const minVal = parseInt(minSlider.value);
                    const maxVal = parseInt(maxSlider.value);
                    const maxRange = Math.max(0, dateHistogramData.length - 1);
                    
                    // Ensure values are within bounds
                    const boundedMinVal = Math.max(0, Math.min(minVal, maxRange));
                    const boundedMaxVal = Math.max(0, Math.min(maxVal, maxRange));
                    
                    // Ensure min doesn't exceed max (allow them to be equal)
                    if (boundedMinVal > boundedMaxVal) {
                        if (this === minSlider) {
                            maxSlider.value = boundedMinVal;
                            minDateIndex = boundedMinVal;
                            maxDateIndex = boundedMinVal;
                        } else {
                            minSlider.value = boundedMaxVal;
                            minDateIndex = boundedMaxVal;
                            maxDateIndex = boundedMaxVal;
                        }
                    } else {
                        minDateIndex = boundedMinVal;
                        maxDateIndex = boundedMaxVal;
                    }
                    
                    // Update sliders to reflect any corrections
                    minSlider.value = minDateIndex;
                    maxSlider.value = maxDateIndex;
                    
                    updateHistogramSelection();
                    updateDateLabels();
                    updateSliderRangeFill();
                    debouncedApplyFilters();
                }
                
                minSlider.addEventListener('input', handleSliderChange.bind(minSlider));
                maxSlider.addEventListener('input', handleSliderChange.bind(maxSlider));
                
                // Also add change events for better compatibility
                minSlider.addEventListener('change', handleSliderChange.bind(minSlider));
                maxSlider.addEventListener('change', handleSliderChange.bind(maxSlider));
                
                // Initial setup will be called after histogram is built
                window.updateSliderRanges = updateSliderRanges;
            }
            
            if (clearDatesBtn) {
                clearDatesBtn.addEventListener('click', function() {
                    minDateIndex = 0;
                    maxDateIndex = Math.max(0, dateHistogramData.length - 1);
                    if (window.updateSliderRanges) {
                        window.updateSliderRanges();
                    }
                    updateHistogramSelection();
                    updateDateLabels();
                    updateSliderRangeFill();
                    applyFilters();
                });
            }
        }

        // Handle window resize to redraw histogram
        window.addEventListener('resize', function() {
            if (dateHistogramData.length > 0) {
                setTimeout(renderDateHistogram, 100); // Delay to allow layout to settle
            }
        });

        // Load the CSV data when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            restoreFilterSettings(); // Restore saved filter settings first
            restorePanelState(); // Restore saved panel state
            loadCSVData();
            setupFilterListeners();
        });
    </script>
</body>
</html>
